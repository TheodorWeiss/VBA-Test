Ок, даю точный M-код (Power Query), который из твоей таблицы TokenTable (Artikelnummer, Token) строит таблицу похожести токенов:
	•	Overlap = сколько артикулов содержат оба токена
	•	DF_A, DF_B (по сути TF после удаления дублей)
	•	Jaccard
	•	ContainmentA = Overlap / DF_A
	•	ContainmentB = Overlap / DF_B

Дальше ты сам фильтруешь: например ContainmentA >= 0.9 + Text.StartsWith(TokenB, TokenA) (если хочешь железное “символы совпадают”).

Ниже 2 запроса. Их можно вставить как два отдельных Query в Advanced Editor.

⸻

1) TokenDF (DF/TF по токенам)

Создай новый Query TokenDF:

let
    // !!! замени TokenTable на имя твоего запроса с колонками Artikelnummer, Token
    Source = TokenTable,

    // 1) Убираем дубли: один Token один раз на Artikel
    Dedup = Table.Distinct(Source, {"Artikelnummer", "Token"}),

    // 2) DF = сколько артикулов содержит токен
    Grouped = Table.Group(Dedup, {"Token"}, {{"DF", each Table.RowCount(_), Int64.Type}}),

    // (опционально) фильтр шума: токены, которые встречаются хотя бы 3 раза
    Filtered = Table.SelectRows(Grouped, each [DF] >= 3)
in
    Filtered

Если не хочешь фильтр DF >= 3 — убери строку Filtered и в in верни Grouped.

⸻

2) TokenPairs (Overlap + Jaccard + Containment)

Создай новый Query TokenPairs:

let
    // !!! замени TokenTable на имя твоего запроса с колонками Artikelnummer, Token
    Source0 = TokenTable,

    // 1) Убираем дубли: один Token один раз на Artikel
    Source = Table.Distinct(Source0, {"Artikelnummer", "Token"}),

    // 2) (опционально) заранее отфильтруем редкие токены через TokenDF
    //    Если хочешь без фильтра — закомментируй 2 строки FilterJoin + ExpandKeep
    FilterJoin = Table.NestedJoin(Source, {"Token"}, TokenDF, {"Token"}, "t", JoinKind.Inner),
    ExpandKeep = Table.ExpandTableColumn(FilterJoin, "t", {"DF"}, {"DF_tmp"}),

    // 3) Self-join по Artikelnummer: получаем пары токенов внутри одного артикула
    SelfJoin = Table.NestedJoin(ExpandKeep, {"Artikelnummer"}, ExpandKeep, {"Artikelnummer"}, "R", JoinKind.Inner),
    Expanded = Table.ExpandTableColumn(SelfJoin, "R", {"Token"}, {"TokenB"}),
    Renamed = Table.RenameColumns(Expanded, {{"Token", "TokenA"}}),

    // 4) Убираем A=A
    NoSelf = Table.SelectRows(Renamed, each [TokenA] <> [TokenB]),

    // 5) Убираем дубли пар (A,B) и (B,A)
    //    Оставляем только где TokenA < TokenB (лексикографически)
    OneSide = Table.SelectRows(NoSelf, each [TokenA] < [TokenB]),

    // 6) Считаем Overlap = количество строк (т.е. количество артикулов, где пара встретилась)
    PairCounts = Table.Group(OneSide, {"TokenA", "TokenB"}, {{"Overlap", each Table.RowCount(_), Int64.Type}}),

    // 7) Подтягиваем DF для TokenA
    JoinA = Table.NestedJoin(PairCounts, {"TokenA"}, TokenDF, {"Token"}, "A", JoinKind.LeftOuter),
    ExpandA = Table.ExpandTableColumn(JoinA, "A", {"DF"}, {"DF_A"}),

    // 8) Подтягиваем DF для TokenB
    JoinB = Table.NestedJoin(ExpandA, {"TokenB"}, TokenDF, {"Token"}, "B", JoinKind.LeftOuter),
    ExpandB = Table.ExpandTableColumn(JoinB, "B", {"DF"}, {"DF_B"}),

    // 9) Метрики
    AddUnion = Table.AddColumn(ExpandB, "Union", each [DF_A] + [DF_B] - [Overlap], Int64.Type),
    AddJaccard = Table.AddColumn(AddUnion, "Jaccard", each if [Union] = 0 then null else Number.From([Overlap]) / Number.From([Union]), type number),

    AddContA = Table.AddColumn(AddJaccard, "ContainmentA", each if [DF_A] = 0 then null else Number.From([Overlap]) / Number.From([DF_A]), type number),
    AddContB = Table.AddColumn(AddContA, "ContainmentB", each if [DF_B] = 0 then null else Number.From([Overlap]) / Number.From([DF_B]), type number),

    // 10) (опционально) Сортировка — сначала самые сильные связи
    Sorted = Table.Sort(AddContB, {{"ContainmentA", Order.Descending}, {"Jaccard", Order.Descending}, {"Overlap", Order.Descending}})
in
    Sorted


⸻

Как использовать результат (без “кучи допущений”)

Твои условия “символы токена должны совпадать с каноном” можно реализовать вообще без канона:

A) Кандидаты на “обрубок → полная форма”

Фильтруй TokenPairs так:
	1.	ContainmentA >= 0.9 (почти все появления A включены в B)
	2.	Text.StartsWith(TokenB, TokenA) (строгое совпадение символов, A — префикс B)
	3.	DF_B > DF_A (B более распространён)

Это даст пары вида:
	•	adventsk → adventskalender
	•	но не даст schwarz → schwart (не префикс)
	•	и bier → bierschinken отрежется обычно containment’ом (будет далеко < 0.9)

B) Если хочешь совсем жёстко против bier→bierschinken

Добавь ещё:
	•	Text.Length(TokenA) <= 6 (нормализуем только коротышей)

⸻

Важно про производительность

Self-join взрывается по размеру. Поэтому рекомендую:
	•	оставить TokenDF фильтр DF >= 3 (или >= 5)
	•	или вообще работать по топ-N токенов (например DF>=20) для первой итерации

⸻

Если напишешь, как у тебя реально называются колонки (точно Artikelnummer/Token?) и имя запроса исходной таблицы (у тебя на скринах есть TokenTable), я подставлю 1-в-1, чтобы можно было просто копипастить без правок.
