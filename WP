(txt as nullable text) as nullable text =>
let
    // 0) защита от null
    SourceText = if txt = null then "" else Text.From(txt),

    // 1) нормализуем разделители -> "###"
    //    делаем это через список замен (надёжно и читаемо)
    ReplPairs = {
        {" | ", "###"},
        {"|",   "###"},
        {" #### ", "###"},
        {"####", "###"},
        {"##",  "###"}
    },

    Normalized =
        List.Accumulate(
            ReplPairs,
            SourceText,
            (state as text, pair as list) => Text.Replace(state, pair{0}, pair{1})
        ),

    // 2) разбиваем на сегменты по ###
    Segments =
        List.Transform(
            Text.Split(Normalized, "###"),
            each Text.Trim(_)
        ),

    // 3) извлечение всех числовых последовательностей длиной >= 4 из одного сегмента
    ExtractNums = (s as text) as list =>
        let
            chars = Text.ToList(s),

            scan =
                List.Generate(
                    () => [i = 0, cur = ""],
                    each [i] < List.Count(chars),
                    each
                        let
                            ch = chars{[i]},
                            isDigit = ch >= "0" and ch <= "9",
                            newCur = if isDigit then [cur] & ch else ""
                        in
                            [i = [i] + 1, cur = newCur],
                    each [cur]
                ),

            valid = List.Select(scan, each Text.Length(_) >= 4)
        in
            valid,

    // 4) применяем ко всем сегментам и объединяем
    AllNums = List.Combine(List.Transform(Segments, each ExtractNums(_))),

    // 5) убираем дубликаты (если нужно сохранять порядок — ок, так и будет)
    DistinctNums = List.Distinct(AllNums),

    // 6) финальный результат
    Result = if List.Count(DistinctNums) = 0 then null else Text.Combine(DistinctNums, "###")
in
    Result
