Принято. Тогда делаем два изменения в логике и идём короткими шагами 1–3.

Что меняем по логике
	1.	KW в Target не используем (можно оставить, но не участвует ни в фильтрах, ни в join).
	2.	Aktionsschema (у тебя на скрине как Aktionsschema / Aktionsschema? / Aktionsschema = Knüller 1) — ключевой фильтр:
	•	для каждого TargetID берём его Aktionsschema
	•	ищем совпадения артикулов только внутри Base с тем же Aktionsschema

⸻

Шаг 1 — Параметр порога (10%)

Power Query → Start → Manage Parameters → New Parameter
	•	Name: pMinSim
	•	Type: Decimal Number
	•	Current Value: 0.1

Готово.

⸻

Шаг 2 — Функция разбиения списка артикулов

Создай Blank Query fxSplitArtikel и вставь:

(t as nullable text, optional delimiter as nullable text) as table =>
let
    d = if delimiter = null then ";" else delimiter,
    s = if t = null then "" else t,
    parts = List.Transform(Text.Split(s, d), each Text.Trim(_)),
    nonEmpty = List.Select(parts, each _ <> ""),
    distinct = List.Distinct(nonEmpty),
    tbl = Table.FromList(distinct, Splitter.SplitByNothing(), {"Artikel"}, null, ExtraValues.Error)
in
    tbl

Готово.

⸻

Шаг 3 — Два “Stage” запроса с Aktionsschema (Target и Base)

3.1 Target_Stage (KW игнорируем, Aktionsschema оставляем)

Создай запрос Target_Stage:

let
    Source = TargetArt,   // <-- имя твоей таблицы/запроса в PQ
    Keep = Table.SelectColumns(Source, {
        "TargetID",
        "Aktionsschema",
        "Umsatz, Mio € Aktion",
        "Umsatz, Mio € Aktion mehr"
    }),
    Ren = Table.RenameColumns(Keep, {
        {"Umsatz, Mio € Aktion", "Umsatz_Aktion"},
        {"Umsatz, Mio € Aktion mehr", "Umsatz_Aktionmehr"}
    }),
    Types = Table.TransformColumnTypes(Ren, {
        {"TargetID", type text},
        {"Aktionsschema", type text},
        {"Umsatz_Aktion", type number},
        {"Umsatz_Aktionmehr", type number}
    })
in
    Types

3.2 Base_Stage (обязательно Aktionsschema)

Создай запрос Base_Stage:

let
    Source = Verbund_ArtikelNr_Liste,   // <-- имя твоей таблицы/запроса в PQ
    Keep = Table.SelectColumns(Source, {
        "BaseID",
        "Aktionsschema",
        "Artikel Umsatz Aktion",
        "Bon Bruttoumsatz (in Mio €) Aktion",
        "Artikel Umsatz Aktionmehr",
        "Rest-bon Bruttoumsatz (in Mio €) Aktionmehr"
    }),
    Ren = Table.RenameColumns(Keep, {
        {"Artikel Umsatz Aktion", "Umsatz_Aktion"},
        {"Bon Bruttoumsatz (in Mio €) Aktion", "Bon_Aktion"},
        {"Artikel Umsatz Aktionmehr", "Umsatz_Aktionmehr"},
        {"Rest-bon Bruttoumsatz (in Mio €) Aktionmehr", "Restbon_Aktionmehr"}
    }),
    Types = Table.TransformColumnTypes(Ren, {
        {"BaseID", type text},
        {"Aktionsschema", type text},
        {"Umsatz_Aktion", type number},
        {"Bon_Aktion", type number},
        {"Umsatz_Aktionmehr", type number},
        {"Restbon_Aktionmehr", type number}
    })
in
    Types


⸻

Как понять, что шаг 3 выполнен правильно
	•	Target_Stage должен показать ~твою Target-таблицу, но только с 4 колонками.
	•	Base_Stage — Base-таблица с переименованными метриками.
	•	Ошибок “Column not found” быть не должно.

⸻

Если сейчас вылетит ошибка из-за названий колонок

На скрине видно, что где-то Aktionsschema может быть написан как Aktionsschema или Aktionsthema (ты в тексте написал Aktuonsthema).
Чтобы я сразу дал 100% верный код, просто напиши точно как в PQ (копипастой) названия:
	•	Target: TargetID, Aktionsschema/…, Umsatz…Aktion, Umsatz…Aktion mehr
	•	Base: BaseID, Aktionsschema/…

⸻

Когда шаги 1–3 готовы, следующий шаг (4) будет: нормализация в артикулы + join по Artikel с доп. условием Aktionsschema (то есть совпадения только внутри Knüller 1, Knüller 2 и т.д.).
